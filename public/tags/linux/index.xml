<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Greyhat.dk</title>
    <link>https://www.greyhat.dk/tags/linux/</link>
    <description>Recent content in Linux on Greyhat.dk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Jul 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.greyhat.dk/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The lost art of debugging for admins #part 1 - Basics and ptrace</title>
      <link>https://www.greyhat.dk/the-lost-art-of-debugging-for-admins-part-1-basics-and-ptrace/</link>
      <pubDate>Fri, 26 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.greyhat.dk/the-lost-art-of-debugging-for-admins-part-1-basics-and-ptrace/</guid>
      <description>

&lt;h1 id=&#34;basics:1d4aff1a42a09f40496282ff08e8849d&#34;&gt;Basics&lt;/h1&gt;

&lt;p&gt;Its been a while since my last update. Been quite busy but also because
I didn&amp;rsquo;t have anything to add. But lately I&amp;rsquo;ve have a urge to write a
series on how to debug on Linux (Works on other platforms as well).
Mostly because it seems that the younger generation (And even older) no
longer debugs their problems but just seek the nearest forum so see if
anyone else had the same issue.&lt;/p&gt;

&lt;p&gt;First rule of debugging is: check logs or use verbose options.&lt;/p&gt;

&lt;p&gt;Once that fails (Many programs have poor logging or inadequate
verbosity) you need to start looking at what the program actually does.
You could just use the &amp;ldquo;look at the source Luuk&amp;rdquo; but for several reasons
that might not be an option.&lt;/p&gt;

&lt;p&gt;| 1) Looking though the source code is one thing, the other is
  understanding it (And you might not be familiar with the language or
  even be a programmer). Its quite time consuming and we all know once
  something stopped working we all have a CEO/Customer on our back.
|  2) Closed source will prevent you from looking at the source code
  (Almost)&lt;/p&gt;

&lt;p&gt;So back to basics on how programs actually work. Programs call software
interrups. Its as simple as that .. lets examine that (You don&amp;rsquo;t need to
be a programmer to understand this).&lt;/p&gt;

&lt;p&gt;A simple Hello world program (Written in 32bit assembly language to keep
the calls to the kernel clean) to demonstrate it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;    .data 

    HelloWorldString:
        .ascii &amp;quot;Hello World\n&amp;quot;

    .text 

    .globl _start 

    _start:
        # Load all the arguments for write () 

        movl $4, %eax
        movl $1, %ebx
        movl $HelloWorldString, %ecx
        movl $12, %edx
        int $0x80

        # Need to exit the program 

        movl $1, %eax
        movl $0, %ebx
        int $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have split the _start section up in 2 fragments. One for the actually
writing of &amp;ldquo;Hello world&amp;rdquo; and one for a clean exit. Notice the int $0x80
.. these are software interrups calling the kernel. Now there is about
300 calls you can make, thats about it.&lt;/p&gt;

&lt;p&gt;First section&lt;/p&gt;

&lt;p&gt;this is the actual sys_write call as defined in
/usr/include/asm/unistd.h (it includes a unistd_64.h or unistd_32.h
depending your platform)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        movl $4, %eax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;file descriptor (in this case 1=STDOUT)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        movl $1, %ebx 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pointer to where the string &amp;ldquo;Hello World&amp;rdquo; is located&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        movl $HelloWorldString, %ecx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;string length of &amp;ldquo;Hello World\n&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        movl $12, %edx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;call the kernel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        int $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The equivalent call in C is the ssize_t write(int fd, const void *buf,
size_t count) (man 2 write)&lt;/p&gt;

&lt;p&gt;Second section is just like the above&lt;/p&gt;

&lt;p&gt;sys_close call (1)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        movl $1, %eax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;exit status (0=all ok)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        movl $0, %ebx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Call kernel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;        int $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The equivalent call in C is the void _exit(int status) (man 2 exit)&lt;/p&gt;

&lt;p&gt;So lets run the program&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # as -o HelloWorldProgram.o HelloWorldProgram.s
    # ld -o HelloWorldProgram HelloWorldProgram.o
    # ./HelloWorldProgram 
    Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it works and that brings in the first tool for debugging.&lt;/p&gt;

&lt;h1 id=&#34;strace-1-trace-system-calls-and-signals:1d4aff1a42a09f40496282ff08e8849d&#34;&gt;strace(1) (trace system calls and signals)&lt;/h1&gt;

&lt;p&gt;running HelloWorldProgram via strace shows that calls are made (Like we
didn&amp;rsquo;t already knew :) )&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # strace ./HelloWorldProgram
    execve(&amp;quot;./HelloWorldProgram&amp;quot;, [&amp;quot;./HelloWorldProgram&amp;quot;], [/* 19 vars */]) = 0
    write(1, &amp;quot;Hello World\n&amp;quot;, 12Hello World
    )           = 12
    _exit(0)                                = ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it starts the program, writes (our sys_write) Hello World and then
exits (our sys_close).&lt;/p&gt;

&lt;p&gt;Now this is just a boring example so lets find a better use case.&lt;/p&gt;

&lt;h1 id=&#34;use-case-1:1d4aff1a42a09f40496282ff08e8849d&#34;&gt;Use case #1&lt;/h1&gt;

&lt;p&gt;The use case for this debugging: A user cannot upload files via vsftpd
and complains. Nothing in the logs indicating other than the permissions
are wrong (Because of the &amp;ldquo;Create directory operation failed&amp;rdquo; error
message from the ftp client). So lets examine&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # quota -q
    # quota kgn
    Disk quotas for user kgn (uid 1008): none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quotas seems fine and permissions are set to 777 (bad choice but this
was the case). I created a session by connecting to the ftp server&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # ftp 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;login and then find the process using ps in a second terminal. Now
connect strace to the vsftpd process (in my case pid 12047). Then try to
create a directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # strace -p 12047
    Process 12047 attached - interrupt to quit
    recvfrom(0, &amp;quot;MKD kgntest\r\n&amp;quot;, 4096, MSG_PEEK, NULL, NULL) = 13
    read(0, &amp;quot;MKD kgntest\r\n&amp;quot;, 13)          = 13
    getcwd(&amp;quot;/&amp;quot;, 4096)                       = 2
    mkdir(&amp;quot;kgntest&amp;quot;, 0777)                  = -1 EDQUOT (Disk quota exceeded)
    write(0, &amp;quot;550 Create directory operation f&amp;quot;..., 40) = 40
    getpid()                                = 3
    fcntl(3, F_SETLKW, {type=F_WRLCK, whence=SEEK_SET, start=0, len=0}) = 0
    write(3, &amp;quot;Thu Jul 25 20:48:20 2013 [pid 3]&amp;quot;..., 97) = 97
    fcntl(3, F_SETLK, {type=F_UNLCK, whence=SEEK_SET, start=0, len=0}) = 0
    rt_sigaction(SIGALRM, {0x4151d0, ~[RTMIN RT_1], SA_RESTORER, 0x7fed483d61e0}, NULL, 8) = 0
    alarm(300)                              = 230
    recvfrom(0, 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So lets go through the above example.&lt;/p&gt;

&lt;p&gt;The command &amp;ldquo;mkdir kgntest&amp;rdquo; received via the network to the process&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    recvfrom(0, &amp;quot;MKD kgntest\r\n&amp;quot;, 4096, MSG_PEEK, NULL, NULL) = 13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read the command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    read(0, &amp;quot;MKD kgntest\r\n&amp;quot;, 13)          = 13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change the directory to / (its chrooted)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    getcwd(&amp;quot;/&amp;quot;, 4096)                       = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The actual command for creating a directory (using 777) and this fails
with EDQUOT (Disk quota exceeded). So now we know that its the quota and
not the vsftpd server or permissions (The actual fix for this is
irrelevant)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    mkdir(&amp;quot;kgntest&amp;quot;, 0777)                  = -1 EDQUOT (Disk quota exceeded)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;use-case-2:1d4aff1a42a09f40496282ff08e8849d&#34;&gt;Use case #2&lt;/h1&gt;

&lt;p&gt;Debugging a program that says its already running even though its not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # puppet agent --test
    notice: Run of Puppet configuration client already in progress; skipping
    # ps -ef|grep puppet
    root     11562 11281  0 14:08 pts/1    00:00:00 grep puppet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great, lets fire up strace&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # strace puppet agent --test
    ... (a lot of output removed)
    mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb701c000
    _llseek(6, 0, [0], SEEK_CUR)            = 0
    read(6, &amp;quot;&amp;quot;, 4096)                       = 0
    close(6)                                = 0
    munmap(0xb701c000, 4096)                = 0
    kill(0, SIG_0)                          = 0
    stat64(&amp;quot;/var/lib/puppet/state/puppetdlock&amp;quot;, {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
    gettimeofday({1374840585, 567949}, NULL) = 0
    rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
    write(1, &amp;quot;\33[0;36mnotice: Run of Puppet con&amp;quot;..., 83notice: Run of Puppet configuration client already in progress; skipping) = 83
    write(1, &amp;quot;\n&amp;quot;, 1
    )                       = 1
    time(NULL)                              = 1374840585
    send(5, &amp;quot;&amp;lt;29&amp;gt;Jul 26 14:09:45 puppet-agent&amp;quot;..., 105, MSG_NOSIGNAL) = 105
    rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
    rt_sigaction(SIGINT, {SIG_DFL, [INT], SA_RESTART}, {0xb76e9bf0, [], 0}, 8) = 0
    close(4)                                = 0
    munmap(0xb72fb000, 4096)                = 0
    close(3)                                = 0
    munmap(0xb72fc000, 4096)                = 0
    exit_group(1)                           = ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so just before we get the error message &amp;ldquo;Run of Puppet configuration
client already in progress; skipping&amp;rdquo; there is a&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    stat64(&amp;quot;/var/lib/puppet/state/puppetdlock&amp;quot;, {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So puppet seems to have crashed. It created a lock file in order not to
run more than once but when crashed it forgot to cleanup.&lt;/p&gt;

&lt;p&gt;| So lets fix it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # rm /var/lib/puppet/state/puppetdlock
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion:1d4aff1a42a09f40496282ff08e8849d&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;So now you know 2 things .. how programs actually works and how strace
can help you find the problem (strace (Linux), dtrace (BSD), truss (All
platforms))&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DNS amplification by example</title>
      <link>https://www.greyhat.dk/dns-amplification-by-example/</link>
      <pubDate>Mon, 22 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.greyhat.dk/dns-amplification-by-example/</guid>
      <description>

&lt;h1 id=&#34;how-it-works:f4145162e1daaabbe3a28d9188ad62da&#34;&gt;How it works&lt;/h1&gt;

&lt;p&gt;DNS amplification is very easy to make and quite effective. An attacker
finds a DNS resolver that is public, creates a spoofed UDP DNS request
originating from the targets address sending the DNS response to the
target. The trick in this attack is to create a bigger output then input
(hence the amplification). What better way than to request a list of
authority records for a top level like .com&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    # dig soa com @localhost

    ; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.7.3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; soa com @localhost
    ;; global options: +cmd
    ;; Got answer:
    ;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 60774
    ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 13, ADDITIONAL: 0

    ;; QUESTION SECTION:
    ;com.               IN  SOA

    ;; ANSWER SECTION:
    com.            837 IN  SOA a.gtld-servers.net. nstld.verisign-grs.com. 1366568135 1800 900 604800 86400

    ;; AUTHORITY SECTION:
    com.            92359   IN  NS  b.gtld-servers.net.
    com.            92359   IN  NS  m.gtld-servers.net.
    com.            92359   IN  NS  l.gtld-servers.net.
    com.            92359   IN  NS  f.gtld-servers.net.
    com.            92359   IN  NS  c.gtld-servers.net.
    com.            92359   IN  NS  d.gtld-servers.net.
    com.            92359   IN  NS  g.gtld-servers.net.
    com.            92359   IN  NS  e.gtld-servers.net.
    com.            92359   IN  NS  k.gtld-servers.net.
    com.            92359   IN  NS  h.gtld-servers.net.
    com.            92359   IN  NS  j.gtld-servers.net.
    com.            92359   IN  NS  a.gtld-servers.net.
    com.            92359   IN  NS  i.gtld-servers.net.

    ;; Query time: 23 msec
    ;; SERVER: ::1#53(::1)
    ;; WHEN: Sun Apr 21 20:17:01 2013
    ;; MSG SIZE  rcvd: 300
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at this using tcpdump it gets quite clear that the request is
quite smaller than the response&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    20:17:01.146195 IP6 (hlim 64, next-header UDP (17) payload length: 29) ::1.43296 &amp;gt; ::1.53: [udp sum ok] 60774+ SOA? com. (21)
    20:17:01.168318 IP6 (hlim 64, next-header UDP (17) payload length: 308) ::1.53 &amp;gt; ::1.43296: [udp sum ok] 60774 q: SOA? com. 1/13/0 com. SOA a.gtld-servers.net. nstld.verisign-grs.com. 1366568135 1800 900 604800 86400 ns: com. NS b.gtld-servers.net., com. NS m.gtld-servers.net., com. NS l.gtld-servers.net., com. NS f.gtld-servers.net., com. NS c.gtld-servers.net., com. NS d.gtld-servers.net., com. NS g.gtld-servers.net., com. NS e.gtld-servers.net., com. NS k.gtld-servers.net., com. NS h.gtld-servers.net., com. NS j.gtld-servers.net., com. NS a.gtld-servers.net., com. NS i.gtld-servers.net. (300)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The request in this case is 21 bytes and the response is 300 bytes (That
is almost 15 times bigger) and this is without DNSSEC (DNSSEC has a much
bigger response). All these requests will of course be dropped by the
target machine but making enough of these will simply flood the
bandwidth of the server/router (Or even ISP) with very little effort.&lt;/p&gt;

&lt;h1 id=&#34;behind-the-scene:f4145162e1daaabbe3a28d9188ad62da&#34;&gt;Behind the scene&lt;/h1&gt;

&lt;p&gt;Now there is plenty of tools out for spoofing packages or one could
simply rent a botnet. But I&amp;rsquo;m a strong believer in knowing how is the
key to prevent it so lets examine how to create a spoofed UDP DNS
request using gcc and Linux.&lt;/p&gt;

&lt;p&gt;The systemcall sendto(2) is used for sending data but when combined with
raw sockets you get to customise the OSI layers (&lt;a href=&#34;http://en.wikipedia.org/wiki/IPv4_header#Header&#34; title=&#34;IP header&amp;quot; and [UDP header](http://en.wikipedia.org/wiki/User_Datagram_Protocol &amp;quot;UDP header&#34;&gt;IP header&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I have provided an example on how to create a spoofed DNS request but
the interesting parts are really&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;            packet.ip.ip_dst.s_addr = inet_addr(&amp;quot;192.168.1.1&amp;quot;);
            packet.ip.ip_src.s_addr = inet_addr(&amp;quot;192.168.1.7&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;            remote_addr.sin_addr.s_addr = packet.ip.ip_dst.s_addr;
            remote_addr.sin_port = packet.udp.uh_dport;
            remote_addr.sin_family = AF_INET;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest is just basic networking code using C.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://greyhat.dk/toolbox/dns_amplification.c&#34; title=&#34;Example of DNS amplification&#34;&gt;dns_amplification.c&lt;/a&gt;
only demonstrates how its done and is not suitable for a realworld
effective DOS. Buffering request like &amp;ldquo;the low bit ion cannon&amp;rdquo; and using
several toplevel soa request (.com, .eu, .edu etc) and adding lots of
DNS servers would make it effective.&lt;/p&gt;

&lt;h1 id=&#34;how-to-defend-against-this-attack:f4145162e1daaabbe3a28d9188ad62da&#34;&gt;How to defend against this attack&lt;/h1&gt;

&lt;p&gt;Since this is a bandwidth attack its a matter of having enough bandwidth
and being able to reject it. It might sound easy but its quite common to
see attacks using more than 1Gbit/s and this is where your standard
firewall most likely is already flooded and can no longer process data.
This is where the ISP comes in and can help prevent the attack by
blocking the attack in the core network.&lt;/p&gt;

&lt;p&gt;Now &lt;a href=&#34;http://openresolverproject.org/&#34; title=&#34;Openresolver project&#34;&gt;openresolverproject.org&lt;/a&gt;
uncovered a lot of open DNS resolvers (Roughly counted more than
20.000+) and if the attacker was using all these (And a botnet) and
assuming they all have a 1Gbit/s connection you could create a
19.5TBit/s attack!. We have already seen a 300Gbit/s attack on spamhaus
causing a major slowdown on the internet. But a 19.5TB attack would take
down large parts of the internet so of course no ISP can prevent this.&lt;/p&gt;

&lt;h1 id=&#34;why-is-this-attack-even-possible:f4145162e1daaabbe3a28d9188ad62da&#34;&gt;Why is this attack even possible&lt;/h1&gt;

&lt;p&gt;Several parties besides the attacker come to mind here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Software vendors for not making a better default configuration making
it a open resolver per default&lt;/li&gt;
&lt;li&gt;End users who install software not knowing how to prober configure
the software&lt;/li&gt;
&lt;li&gt;ISPs for not blocking spoofed traffic from their network (They should
block outbound traffic that does not originate from the network)&lt;/li&gt;
&lt;li&gt;ISPs for not telling the end user about this security issue and not
acting on it (Blocking ports)&lt;/li&gt;
&lt;li&gt;ISPs for not responding to abuse complaints&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As it is now things will never get fixed. Spamhaus created a lookup
database for open dns resolvers (So ISP could block for these
misconfigred servers) but since the ISP properly would loose customers
due to blocking they will never use it (And they would have to use
excessive CPU on the border routers to handle it). And since there is no
law to actually get abuse complaints enforced the ISP will not take
responsibility. So it all comes down to money in the end.&lt;/p&gt;

&lt;p&gt;The way I would like it to work is to simply&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a abuse report to the ISP and CC ripe (or a taskforce for
handling abuse world wide) for every abuse case&lt;/li&gt;
&lt;li&gt;The task force should register the amount of abuse based on allocated
subnet&lt;/li&gt;
&lt;li&gt;Fail to handle abuse enough times and the task force should simply
remove the subnet allocation removing the network from the ISP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This will make the ISP care about security since loosing IP&amp;rsquo;s will force
their customers offline. And ISPs known to host spammers would simply be
shutdown by loosing all their IPs.&lt;/p&gt;

&lt;p&gt;The last DNS amplification I handled I created a script for creating
abuse reports. Just to take the top 2 abuse accounts from the list of
open resolvers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;        189 abuse@oneandone.net
       1503 abuse@ovh.net
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So 1503 servers with open resolvers from one single ISP .. Created a
abuse report on this within 12 hours of the incident (More than 10 days
ago) and all of these servers are still online and I never heard a
single word (Weird enough this seems to be the standard not to reply).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>